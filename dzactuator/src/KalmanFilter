
#include "dzactuator.h"
#include "Quaternion_Solution.h"
#include <tf2_geometry_msgs/tf2_geometry_msgs.h>
#include <tf2/convert.h>
#include <tf2/utils.h>
#include <Eigen/Dense>

sensor_msgs::Imu Mpu6050;

turn_on_robot::turn_on_robot() : Power_voltage(0) {
    // 原始初始化代码
    linear_Speed = 0;
    ThetaSpeed = 0;
    ticksPerMeter = 0;
    ticksPer2PI = 0;
    leftDistance = 0;
    rightDistance = 0;
    calibrate_lineSpeed = 0;
    last_Battery_Percentage = 0;
    count_B = 0;
    count_A = 0;
    count_C = 0;

    Power_max = 12;
    Power_min = 10;

    stop_point_signal_msg = 0;
    find_center = false;
    return_center = false;
    memset(&Robot_Pos, 0, sizeof(Robot_Pos));
    memset(&Robot_Vel, 0, sizeof(Robot_Vel));
    memset(&Receive_Data, 0, sizeof(Receive_Data));
    memset(&Send_Data, 0, sizeof(Send_Data));
    memset(&Mpu6050_Data, 0, sizeof(Mpu6050_Data));
    memset(&moveBaseControl, 0, sizeof(sMartcarControl));
    moveBaseControl.Position_0 = 2047;
    moveBaseControl.Position_1 = 2047;
    moveBaseControl.Speed_0 = 200;
    moveBaseControl.Speed_1 = 200;
    moveBaseControl.Time_0 = 0;
    moveBaseControl.Time_1 = 0;
    moveBaseControl.VoiceSwitch = 0;

    ros::NodeHandle private_nh("~");
    private_nh.param<std::string>("serial_port_name", serial_port_name, "/dev/ttyACM0");
    private_nh.param<int>("serial_baud_rate", serial_baud_rate, 115200);
    private_nh.param<std::string>("odom_frame_id", odom_frame_id, "odom");
    private_nh.param<std::string>("robot_frame_id", robot_frame_id, "base_link");
    private_nh.param<std::string>("gyro_frame_id", gyro_frame_id, "imu_link");
    private_nh.param("calibrate_lineSpeed", calibrate_lineSpeed, calibrate_lineSpeed);
    private_nh.param("ticksPerMeter", ticksPerMeter, ticksPerMeter);
    private_nh.param("ticksPer2PI", ticksPer2PI, ticksPer2PI);

    voltage_publisher = n.advertise<std_msgs::Float32>("PowerVoltage", 10);
    Battery_Percentage_pub = n.advertise<std_msgs::Float32>("Battery_Percentage", 10);
    odom_publisher = n.advertise<nav_msgs::Odometry>("odom", 50);
    imu_publisher = n.advertise<sensor_msgs::Imu>("raw", 20);
    pub_diff = n.advertise<sensor_msgs::Imu>("imu_data", 20);
    pub_imu_msg_valid = n.advertise<std_msgs::UInt8>("imu_msg_valid", 10);
    pub_odom_msg_valid = n.advertise<std_msgs::UInt8>("odom_msg_valid", 10);
    pub_LaserShot_Command = n.advertise<std_msgs::UInt8>("LaserShot_Command", 10);

    sub_movebase_angle = n.subscribe("pursuitAngle", 1, &turn_on_robot::callback_movebase_angle, this);
    sub_cmd_vel = n.subscribe("cmd_vel", 1, &turn_on_robot::callback_cmd_vel_angle, this);
    sub_monter_control = n.subscribe("/carema_monter_node/monter_control", 1, &turn_on_robot::callback_monter_control, this);
    sub_offset_center = n.subscribe("offset_center", 1, &turn_on_robot::callback_offset_center, this);
    sub_stop_point_signal = n.subscribe("/move_base/stop_signal", 1, &turn_on_robot::callback_stop_point_signal, this);
    sub_voice_switch = n.subscribe("/voice_switch", 1, &turn_on_robot::callback_voice_switch, this);

    imu_buff.clear();
    imu_state.clear();
    imu_flag = 0;
    g0 = 9.8;
    num_imu = 40;

    ROS_INFO_STREAM("Data ready");

    std::cout << "Copyright©2016-2020 dzactuator. All rights reserved " << std::endl;
    std::cout << "*****dzactuator:parameters*******************" << std::endl;
    std::cout << "serial_port_name:" << serial_port_name << std::endl;
    std::cout << "serial_baud_rate:" << serial_baud_rate << std::endl;
    std::cout << "calibrate_lineSpeed:" << calibrate_lineSpeed << std::endl;
    std::cout << "ticksPerMeter:" << ticksPerMeter << std::endl;
    std::cout << "ticksPer2PI:" << ticksPer2PI << std::endl;
    std::cout << "Power_max:" << Power_max << std::endl;
    std::cout << "Power_min:" << Power_min << std::endl;
    std::cout << "gyro_frame_id:" << gyro_frame_id << std::endl;
    std::cout << "*****dzactuator:parameters end***************" << std::endl;

    try {
        Stm32_Serial.setPort(serial_port_name);
        Stm32_Serial.setBaudrate(serial_baud_rate);
        serial::Timeout _time = serial::Timeout::simpleTimeout(30);
        Stm32_Serial.setTimeout(_time);
        Stm32_Serial.open();
    } catch (serial::IOException &e) {
        ROS_ERROR_STREAM("dzactuator can not open serial port,Please check the serial port cable! ");
    }
    if (Stm32_Serial.isOpen()) {
        ROS_INFO_STREAM("dzactuator serial port opened");
    }

    // 新增初始化：卡尔曼滤波和偏移校正
    initKalmanFilter();
    initBiasCorrection();
}

turn_on_robot::~turn_on_robot() {
    // 原始析构函数代码
    Send_Data.tx[0] = FRAME_HEADER;
    Send_Data.tx[1] = 0;
    Send_Data.tx[2] = 0;
    Send_Data.tx[4] = 0;
    Send_Data.tx[3] = 0;
    Send_Data.tx[6] = 0;
    Send_Data.tx[5] = 0;
    Send_Data.tx[8] = 0;
    Send_Data.tx[7] = 0;
    Send_Data.tx[9] = Check_Sum(9, SEND_DATA_CHECK);
    Send_Data.tx[10] = FRAME_TAIL;
    try {
        Stm32_Serial.write(Send_Data.tx, sizeof(Send_Data.tx));
    } catch (serial::IOException &e) {
        ROS_ERROR_STREAM("Unable to send data through serial port");
    }
    Stm32_Serial.close();
}

// 新增：初始化卡尔曼滤波
void turn_on_robot::initKalmanFilter() {
    state = Eigen::VectorXd::Zero(6); // [x, y, θ, v_x, v_y, ω]
    P = Eigen::MatrixXd::Identity(6, 6) * 1.0;
    F = Eigen::MatrixXd::Identity(6, 6);
    dt = 0.02; // 50Hz
    F(0, 3) = dt; // x = x + v_x * dt
    F(1, 4) = dt; // y = y + v_y * dt
    F(2, 5) = dt; // θ = θ + ω * dt
    H = Eigen::MatrixXd::Zero(6, 6);
    H(0, 3) = 1.0; // v_x
    H(1, 4) = 1.0; // v_y
    H(2, 5) = 1.0; // ω
    H(3, 3) = dt;  // a_x
    H(4, 4) = dt;  // a_y
    H(5, 5) = dt;  // ω_z
    Q = Eigen::MatrixXd::Identity(6, 6) * 0.01;
    R = Eigen::MatrixXd::Identity(6, 6);
    R.diagonal() << 0.1, 0.1, 0.01, 0.5, 0.5, 0.05;
}

// 新增：初始化偏移校正
void turn_on_robot::initBiasCorrection() {
    last_bias_update = ros::Time::now();
    bias_update_interval = 300.0; // 5分钟
    stationary_count = 0;
}

// 新增：卡尔曼滤波更新
void turn_on_robot::kalmanFilterUpdate(const Eigen::VectorXd& measurement) {
    state = F * state;
    P = F * P * F.transpose() + Q;
    Eigen::VectorXd y = measurement - H * state;
    Eigen::MatrixXd S = H * P * H.transpose() + R;
    Eigen::MatrixXd K = P * H.transpose() * S.inverse();
    state = state + K * y;
    P = (Eigen::MatrixXd::Identity(6, 6) - K * H) * P;

    Robot_Pos.X = state(0);
    Robot_Pos.Y = state(1);
    Robot_Pos.Z = state(2);
    linear_Speed = state(3); // v_x
    ThetaSpeed = state(5);   // ω
    Robot_Vel.Left = (state(3) - state(5) * CARL / 2) * ticksPerMeter;
    Robot_Vel.Right = (state(3) + state(5) * CARL / 2) * ticksPerMeter;
}

// 新增：周期性偏移校正
void turn_on_robot::updateBiasIfStationary() {
    bool isStationary = !montion_flag && std::abs(linear_Speed) < 0.01 && std::abs(ThetaSpeed) < 0.01;
    if (isStationary) {
        stationary_count++;
        if (stationary_count >= min_stationary_samples && 
            (ros::Time::now() - last_bias_update).toSec() >= bias_update_interval) {
            Cal_state_error();
            last_bias_update = ros::Time::now();
            stationary_count = 0;
            ROS_INFO_STREAM("IMU bias updated");
        }
    } else {
        stationary_count = 0;
    }
}

// 修改：均值滤波支持动态窗口
void turn_on_robot::Average_filtering() {
    sensor_msgs::Imu average_imu;
    average_imu.header.stamp = ros::Time::now();
    average_imu.header.frame_id = gyro_frame_id;

    // 动态窗口调整
    max_window_size = montion_flag ? 3 : 10;
    while (imu_buff.size() > max_window_size) {
        imu_buff.pop_front();
    }
    int size = imu_buff.size();
    if (size == 0) return;

    double ax = 0, ay = 0, az = 0, gx = 0, gy = 0, gz = 0;
    for (int i = 0; i < size; i++) {
        ax += imu_buff[i].linear_acceleration.x;
        ay += imu_buff[i].linear_acceleration.y;
        az += imu_buff[i].linear_acceleration.z;
        gx += imu_buff[i].angular_velocity.x;
        gy += imu_buff[i].angular_velocity.y;
        gz += imu_buff[i].angular_velocity.z;
    }

    ax /= size;
    ay /= size;
    az /= size;
    gx /= size;
    gy /= size;
    gz /= size;

    average_imu.angular_velocity.x = gx - err_gx;
    average_imu.angular_velocity.y = gy - err_gy;
    average_imu.angular_velocity.z = gz - err_gz;
    average_imu.linear_acceleration.x = ax - err_ax;
    average_imu.linear_acceleration.y = ay - err_ay;
    average_imu.linear_acceleration.z = az - err_az;

    if (montion_flag) {
        average_imu.orientation_covariance[0] = 1e6;
        average_imu.orientation_covariance[4] = 1e6;
        average_imu.orientation_covariance[8] = 1e-6;
        average_imu.angular_velocity_covariance[0] = 1e6;
        average_imu.angular_velocity_covariance[4] = 1e6;
        average_imu.angular_velocity_covariance[8] = 1e-6;
    } else {
        average_imu.orientation_covariance[0] = 1e6;
        average_imu.orientation_covariance[4] = 1e6;
        average_imu.orientation_covariance[8] = 1e6;
        average_imu.angular_velocity_covariance[0] = 1e6;
        average_imu.angular_velocity_covariance[4] = 1e6;
        average_imu.angular_velocity_covariance[8] = 1e6;
    }

    average_imu.orientation = tf::createQuaternionMsgFromYaw(Robot_Pos.Z);
    imu_correct = average_imu;
    pub_diff.publish(average_imu);
}

// 修改：主控制循环
void turn_on_robot::Control() {
    Robot_Pos.X = 0;
    Robot_Pos.Y = 0;
    Robot_Pos.Z = 0;
    ros::Time current_time, last_time;
    last_time = ros::Time::now();
    ros::Rate rate(50);
    while (ros::ok()) {
        ros::spinOnce();
        if (Get_Sensor_Data_New()) {
            updateBiasIfStationary(); // 周期性偏移校正
            if (imu_flag == 1) {
                Average_filtering(); // 动态窗口调整
                // 卡尔曼滤波更新
                Eigen::VectorXd measurement(6);
                measurement << linear_Speed * cos(Robot_Pos.Z),
                              linear_Speed * sin(Robot_Pos.Z),
                              ThetaSpeed,
                              Mpu6050.linear_acceleration.x,
                              Mpu6050.linear_acceleration.y,
                              Mpu6050.angular_velocity.z;
                kalmanFilterUpdate(measurement);
            }
            Publish_Odom();
            Publish_ImuSensor();
            Publish_Voltage();
            Publish_Battery_Percentage();
            CaremaMontorControl();
            sendCarInfoKernel();
            rate.sleep();
        }
    }
}

// 保留原始函数（省略未修改部分）
void turn_on_robot::Cal_state_error() {
    int size = imu_state.size();
    if (size < num_imu) {
        printf("wait imu data !\n");
        return;
    }
    double ax = 0, ay = 0, az = 0, gx = 0, gy = 0, gz = 0;
    for (int i = 5; i < size; i++) {
        ax += imu_state[i].linear_acceleration.x;
        ay += imu_state[i].linear_acceleration.y;
        az += imu_state[i].linear_acceleration.z;
        gx += imu_state[i].angular_velocity.x;
        gy += imu_state[i].angular_velocity.y;
        gz += imu_state[i].angular_velocity.z;
    }
    err_ax = ax / (size - 5);
    err_ay = ay / (size - 5);
    err_az = az / (size - 5) - g0;
    err_gx = gx / (size - 5);
    err_gy = gy / (size - 5);
    err_gz = gz / (size - 5);
    imu_state.clear();
    std::cout << "IMU bias recalculated successfully!" << std::endl;
}

// 其他原始函数保持不变（省略）

int main(int argc, char **argv) {
    ros::init(argc, argv, "dzactuator");
    turn_on_robot Robot_Control;
    Robot_Control.Control();
    return 0;
}
